<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wireshark-Style Packet Sniffing Lab</title>
<style>
  :root{
    --bg:#f9fafb;        /* page background */
    --panel:#ffffff;     /* card/panel background */
    --muted:#4b5563;     /* muted text */
    --ink:#111827;       /* primary text */
    --accent:#0b63f6;    /* accent color */
    --ok:#16a34a;        /* success green */
    --err:#dc2626;       /* error red */
    --hexbg:#f3f4f6;     /* hex dump background */
    --hexgrid:#e5e7eb;   /* hex grid lines */
    --chip:#e5e7eb;      /* pill chips */
  }

  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font:14px/1.4 ui-sans-serif,system-ui,Segoe UI,Roboto,Inter,Arial
  }
  header{
    padding:14px 18px;
    background:linear-gradient(90deg,#0b63f6,#0a75ff);
    box-shadow:0 2px 0 #0b63f6;
    color:white;
  }
  header h1{margin:0;font-size:1.1rem;font-weight:700;letter-spacing:.2px}
  .layout{display:grid;grid-template-columns:340px 1fr;gap:12px;padding:14px}
  @media (max-width:1000px){.layout{grid-template-columns:1fr}}
  .left,.right{
    background:var(--panel);
    border:1px solid #d1d5db;
    border-radius:10px;
    padding:12px;
  }
  h3{margin:8px 0 6px;font-size:1rem}
  .row{display:flex;gap:6px;margin:6px 0;flex-wrap:wrap}
  label{font-size:.86rem;color:var(--muted)}
  select,input,textarea,button{
    background:#ffffff;
    color:var(--ink);
    border:1px solid #d1d5db;
    border-radius:8px;
    padding:8px;
    font:inherit
  }
  select,input{width:100%}
  textarea{
    width:100%;
    height:110px;
    font-family:ui-monospace,Consolas,Menlo,monospace
  }
  button{cursor:pointer}
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:#0a58d1
  }
  .pill{
    background:var(--chip);
    padding:2px 8px;
    border-radius:999px;
    border:1px solid #d1d5db;
    color:#374151;
    font-size:.78rem
  }
  .split{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .packet{
    background:#ffffff;
    border:1px solid #d1d5db;
    border-radius:10px;
    margin:10px 0
  }
  .pkt-head{
    padding:8px 12px;
    border-bottom:1px solid #d1d5db;
    display:flex;
    justify-content:space-between;
    gap:8px;
    align-items:center
  }
  .pkt-title{font-weight:600}
  details summary{list-style:none;cursor:pointer}
  details summary::-webkit-details-marker{display:none}
  .tree{padding:8px 12px}
  .node{margin:4px 0}
  .node .k{color:#0b63f6}
  .node .v{color:#111827}
  .hexwrap{
    padding:10px;
    border-top:1px solid #d1d5db;
    background:var(--hexbg)
  }
  pre.hex{
    margin:0;
    font:12px/1.35 ui-monospace,Consolas,Menlo,monospace;
    white-space:pre;
    overflow:auto;
    max-height:220px
  }
  .ascii{opacity:.85}
  .hl{background:#dbeafe}
  .filterbar{display:flex;gap:6px}
  .muted{color:var(--muted)}
  .status{font-size:.86rem;margin-top:6px}
  .ok{color:var(--ok)} .err{color:var(--err)}
  .stacksel{display:grid;grid-template-columns:1fr;gap:8px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  .inline{display:inline-flex;gap:6px;align-items:center}
  .hint{font-size:.8rem;color:#6b7280}
  .toolbar{display:flex;gap:6px;flex-wrap:wrap}
  .badge{
    background:#f3f4f6;
    border:1px solid #d1d5db;
    padding:3px 6px;
    border-radius:6px;
    color:#374151;
    font-size:.78rem
  }
</style>

</head>
<body>
<header><h1>Wireshark-Style Packet Sniffing Lab</h1></header>

<div class="layout">
  <div class="left">
    <h3>Generate Packets</h3>
    <div class="stacksel">
      <div class="grid2">
        <div>
          <label>Link</label>
          <select id="selLink">
            <option value="eth" selected>Ethernet II</option>
          </select>
        </div>
        <div>
          <label>Network</label>
          <select id="selNet">
            <option value="ipv4" selected>IPv4</option>
            <option value="ipv6">IPv6</option>
            <option value="arp">ARP</option>
          </select>
        </div>
      </div>
      <div class="grid3" id="transRow">
        <div>
          <label>Transport</label>
          <select id="selTrans">
            <option value="tcp" selected>TCP</option>
            <option value="udp">UDP</option>
            <option value="icmpv4">ICMPv4</option>
            <option value="icmpv6">ICMPv6</option>
            <option value="">(none)</option>
          </select>
        </div>
        <div>
          <label>Application</label>
          <select id="selApp">
            <option value="">(none)</option>
            <option value="dns">DNS</option>
            <option value="http">HTTP</option>
          </select>
        </div>
        <div>
          <label>&nbsp;</label>
          <button class="primary" id="btnGen">Generate Random</button>
        </div>
      </div>
      <div class="hint">Tip: ICMP on IPv6 uses ICMPv6; ICMPv4 requires IPv4.</div>
    </div>

    <h3 style="margin-top:14px">Paste Hex Dump</h3>
    <textarea id="hexInput" placeholder="Paste raw hex bytes here (spaces/newlines allowed)…&#10;Example: 00112233445566778899AABB08004500..."></textarea>
    <div class="toolbar">
      <button id="btnDecode">Decode Hex</button>
      <button id="btnClear">Clear Packets</button>
    </div>
    <div class="status muted" id="status"></div>

    <h3 style="margin-top:14px">Filter</h3>
    <div class="filterbar">
      <input id="filter" placeholder="Wireshark-like filter, e.g. ip.src == 192.168.1.10 and tcp.port == 80" />
      <button id="btnFilter">Apply</button>
      <button id="btnReset">Reset</button>
    </div>
    <div class="hint" style="margin-top:6px">
      Supported: <span class="badge">ip.src/dst</span> <span class="badge">ipv6.src/dst</span> <span class="badge">eth.src/dst</span> <span class="badge">tcp/udp/icmp/icmpv6/dns/http</span> <span class="badge">tcp.port/udp.port</span> <span class="badge">proto == tcp</span> <span class="badge">contains</span> <span class="badge">and/or</span>
    </div>
  </div>

  <div class="right">
    <h3>Captured Packets <span id="pktCount" class="pill">0</span></h3>
    <div id="packets"></div>
  </div>
</div>

<script>
/* ============================== Utilities ============================== */
const toHex = (buf) => Array.from(buf, b => b.toString(16).padStart(2,'0')).join('');
const hexPretty = (buf) => {
  let out = '', ascii = '';
  for(let i=0;i<buf.length;i++){
    if(i%16===0){ out += (i===0?'':'\n') + i.toString(16).padStart(4,'0')+'  '; ascii=''; }
    out += buf[i].toString(16).padStart(2,'0') + (i%2?' ':'');
    ascii += (buf[i]>=32 && buf[i]<127)?String.fromCharCode(buf[i]):'.';
    if(i%16===15){ out += ' '.repeat(1) + ascii; ascii=''; }
  }
  if(buf.length%16!==0){
    const rem = 16 - (buf.length%16);
    out += ' '.repeat(rem*2 + Math.floor(rem/2)) + ' ' + ascii;
  }
  return out.toUpperCase();
};
const parseHexString = (s) => {
  const clean = s.replace(/[^0-9a-fA-F]/g,'');
  if(clean.length%2) throw new Error('Odd number of hex digits.');
  const arr = new Uint8Array(clean.length/2);
  for(let i=0;i<arr.length;i++){ arr[i] = parseInt(clean.substr(i*2,2),16); }
  return arr;
};
const macStr = (b,o)=>[0,1,2,3,4,5].map(i=>b[o+i].toString(16).padStart(2,'0')).join(':').toUpperCase();
const ipv4Str=(b,o)=>[0,1,2,3].map(i=>b[o+i]).join('.');
const ipv6Str=(b,o)=>Array.from({length:8},(_,i)=>((b[o+2*i]<<8)|b[o+2*i+1]).toString(16)).join(':').replace(/\b0{1,3}/g,'').toLowerCase();
const be16=(b,o)=> (b[o]<<8)|b[o+1];
const be32=(b,o)=> (b[o]*2**24 + b[o+1]*2**16 + b[o+2]*2**8 + b[o+3])>>>0;
const put16=(b,o,v)=>{ b[o]= (v>>>8)&0xff; b[o+1]= v&0xff; };
const put32=(b,o,v)=>{ b[o]= (v>>>24)&0xff; b[o+1]= (v>>>16)&0xff; b[o+2]= (v>>>8)&0xff; b[o+3]= v&0xff; };
const rand = (n)=>crypto.getRandomValues(new Uint8Array(n));
const randMAC = ()=> Array.from(rand(6),x=>x.toString(16).padStart(2,'0')).join(':').toUpperCase();
const randIPv4 = ()=> Array.from(rand(4),x=>x%254+1).join('.');
const randIPv6 = ()=> Array.from({length:8},()=>Math.floor(Math.random()*0xffff).toString(16)).join(':');
const randPort = ()=> Math.floor(49152+Math.random()*(65535-49152));
const textEnc = (s)=> new TextEncoder().encode(s);
function internetChecksum(buf) {
  let sum = 0;
  for (let i = 0; i < buf.length; i += 2) {
    const w = (buf[i] << 8) + (buf[i+1] || 0);
    sum += w;
    while (sum > 0xffff) sum = (sum & 0xffff) + (sum >>> 16);
  }
  return (~sum) & 0xffff;
}

/* ============================== Parsers ============================== */
function parseEthernet(buf, off=0){
  if(buf.length-off < 14) throw new Error('Truncated Ethernet');
  const dst = macStr(buf,off), src = macStr(buf,off+6);
  const type = be16(buf,off+12);
  const node = { _range:[off,off+14], layer:'eth', summary:`Ethernet II, Src: ${src}, Dst: ${dst}${type===0x0800?', Type: IPv4':''}${type===0x86dd?', Type: IPv6':''}${type===0x0806?', Type: ARP':''}`,
    fields:[
      ['Destination', dst, [off,off+6]],
      ['Source', src, [off+6,off+12]],
      ['Type', '0x'+type.toString(16).padStart(4,'0'), [off+12,off+14]],
    ],
    dst, src, type
  };
  let next=null;
  if(type===0x0800) next='ipv4';
  else if(type===0x86dd) next='ipv6';
  else if(type===0x0806) next='arp';
  return {node, next, nextOff: off+14};
}

function parseIPv4(buf, off){
  if(buf.length-off<20) throw new Error('Truncated IPv4');
  const vihl=buf[off], ver=vihl>>>4, ihl=(vihl&0x0f)*4;
  if(ver!==4) throw new Error('Not IPv4');
  if(buf.length-off<ihl) throw new Error('Truncated IPv4 header');
  const tos=buf[off+1], totlen=be16(buf,off+2), id=be16(buf,off+4);
  const flagsFrag=be16(buf,off+6), ttl=buf[off+8], proto=buf[off+9], chks=be16(buf,off+10);
  const src=ipv4Str(buf,off+12), dst=ipv4Str(buf,off+16);
  // validate checksum
  const headerCopy = buf.slice(off, off+ihl);
  headerCopy[10]=0; headerCopy[11]=0;
  const calc = internetChecksum(headerCopy);
  const node = {
    _range:[off,off+ihl], layer:'ipv4',
    summary:`Internet Protocol Version 4, Src: ${src}, Dst: ${dst}, Proto: ${proto}`,
    fields:[
      ['Version', ver, [off,off+1]],
      ['IHL', ihl, [off,off+1]],
      ['TOS', '0x'+tos.toString(16).padStart(2,'0'), [off+1,off+2]],
      ['Total Length', totlen, [off+2,off+4]],
      ['Identification', '0x'+id.toString(16).padStart(4,'0'), [off+4,off+6]],
      ['Flags/Frag', '0x'+flagsFrag.toString(16).padStart(4,'0'), [off+6,off+8]],
      ['TTL', ttl, [off+8,off+9]],
      ['Protocol', proto, [off+9,off+10]],
      ['Header Checksum', '0x'+chks.toString(16).padStart(4,'0') + (calc===chks?' (OK)':' (BAD, calc 0x'+calc.toString(16).padStart(4,'0')+')'), [off+10,off+12]],
      ['Source', src, [off+12,off+16]],
      ['Destination', dst, [off+16,off+20]]
    ],
    src, dst, proto, ihl, totlen
  };
  let next=null; if(proto===6) next='tcp'; else if(proto===17) next='udp'; else if(proto===1) next='icmpv4';
  return {node, next, nextOff: off+ihl, payloadEnd: off+totlen};
}

function parseIPv6(buf, off){
  if(buf.length-off<40) throw new Error('Truncated IPv6');
  const ver = buf[off]>>>4; if(ver!==6) throw new Error('Not IPv6');
  const tc = ((buf[off]&0x0f)<<4) | (buf[off+1]>>>4);
  const flow = ((buf[off+1]&0x0f)<<16) | (buf[off+2]<<8) | buf[off+3];
  const payloadLen = be16(buf,off+4); const nextHdr = buf[off+6]; const hop=buf[off+7];
  const src=ipv6Str(buf,off+8), dst=ipv6Str(buf,off+24);
  const node = {
    _range:[off,off+40], layer:'ipv6',
    summary:`Internet Protocol Version 6, Src: ${src}, Dst: ${dst}, Next: ${nextHdr}`,
    fields:[
      ['Version', ver, [off,off+1]],
      ['Traffic Class', '0x'+tc.toString(16), [off,off+2]],
      ['Flow Label', '0x'+flow.toString(16), [off,off+4]],
      ['Payload Length', payloadLen, [off+4,off+6]],
      ['Next Header', nextHdr, [off+6,off+7]],
      ['Hop Limit', hop, [off+7,off+8]],
      ['Source', src, [off+8,off+24]],
      ['Destination', dst, [off+24,off+40]],
    ],
    src, dst, nextHdr, payloadLen
  };
  let next=null; if(nextHdr===6) next='tcp'; else if(nextHdr===17) next='udp'; else if(nextHdr===58) next='icmpv6';
  return {node, next, nextOff: off+40, payloadEnd: off+40+payloadLen};
}

function parseARP(buf, off){
  if(buf.length-off<28) throw new Error('Truncated ARP');
  const htype=be16(buf,off), ptype=be16(buf,off+2), hlen=buf[off+4], plen=buf[off+5], op=be16(buf,off+6);
  const sha = Array.from(buf.slice(off+8, off+8+hlen)).map(b=>b.toString(16).padStart(2,'0')).join(':').toUpperCase();
  const spa = Array.from(buf.slice(off+8+hlen, off+8+hlen+plen)).join('.');
  const tha = Array.from(buf.slice(off+8+hlen+plen, off+8+hlen+plen+hlen)).map(b=>b.toString(16).padStart(2,'0')).join(':').toUpperCase();
  const tpa = Array.from(buf.slice(off+8+hlen+plen+hlen, off+8+hlen+plen+hlen+plen)).join('.');
  const node = {
    _range:[off,off+8+2*hlen+2*plen], layer:'arp',
    summary:`ARP, ${op===1?'Request':'Reply'} ${spa} is-at ${sha}`,
    fields:[
      ['Hardware type', htype, [off,off+2]],
      ['Protocol type', '0x'+ptype.toString(16).padStart(4,'0'), [off+2,off+4]],
      ['HLEN', hlen, [off+4,off+5]],
      ['PLEN', plen, [off+5,off+6]],
      ['Operation', op, [off+6,off+8]],
      ['Sender MAC', sha, [off+8,off+8+hlen]],
      ['Sender IP', spa, [off+8+hlen,off+8+hlen+plen]],
      ['Target MAC', tha, [off+8+hlen+plen, off+8+hlen+plen+hlen]],
      ['Target IP', tpa, [off+8+hlen+plen+hlen, off+8+hlen+2*plen+hlen]],
    ],
    sha, spa, tha, tpa, op
  };
  return {node, next:null, nextOff: node._range[1]};
}

function parseTCP(buf, off, end){
  if(end==null) end = buf.length;
  if(buf.length-off<20) throw new Error('Truncated TCP');
  const sport=be16(buf,off), dport=be16(buf,off+2);
  const seq=be32(buf,off+4), ack=be32(buf,off+8);
  const doff=(buf[off+12]>>>4)*4, flags=buf[off+13];
  const win=be16(buf,off+14), chks=be16(buf,off+16), urg=be16(buf,off+18);
  const node = {
    _range:[off,off+doff], layer:'tcp',
    summary:`Transmission Control Protocol, ${sport} → ${dport}, Flags: 0x${flags.toString(16)}`,
    fields:[
      ['Source Port', sport, [off,off+2]],
      ['Destination Port', dport, [off+2,off+4]],
      ['Sequence Number', seq, [off+4,off+8]],
      ['Acknowledgment Number', ack, [off+8,off+12]],
      ['Data Offset', doff, [off+12,off+13]],
      ['Flags', '0x'+flags.toString(16).padStart(2,'0'), [off+13,off+14]],
      ['Window', win, [off+14,off+16]],
      ['Checksum', '0x'+chks.toString(16).padStart(4,'0'), [off+16,off+18]],
      ['Urgent Pointer', urg, [off+18,off+20]]
    ],
    sport, dport, flags, doff
  };
  const payloadOff = off+doff; const payload = buf.slice(payloadOff, end);
  let app=null;
  if(payload.length){
    // Try HTTP
    if((dport===80 || sport===80 || dport===8080 || sport===8080) && looksHTTP(payload)){
      app = parseHTTP(payload, payloadOff);
    }
  }
  return {node, next: app ? 'app' : null, nextNode: app, nextOff: payloadOff + (app?app._len:0)};
}
function looksHTTP(p){
  const s = new TextDecoder().decode(p.slice(0,8));
  return /^(GET|POST|PUT|HEAD|HTTP\/)/.test(s);
}
function parseHTTP(p, baseOff){
  // parse start-line + headers until CRLFCRLF
  const text = new TextDecoder().decode(p);
  const m = text.match(/\r\n\r\n/);
  const end = m ? m.index+4 : Math.min(text.length, 1024);
  const head = text.slice(0,end);
  const lines = head.split(/\r\n/).filter(x=>x.length);
  const node = {
    _range:[baseOff, baseOff + new TextEncoder().encode(head).length],
    layer:'http',
    summary: `Hypertext Transfer Protocol: ${lines[0]||'(start-line)'}`,
    fields: lines.map((ln,i)=> i===0? ['Start-Line', ln, null] : ['Header', ln, null]),
    _len: new TextEncoder().encode(head).length,
    startLine: lines[0]||'',
  };
  return node;
}

function parseUDP(buf, off, end){
  if(end==null) end=buf.length;
  if(buf.length-off<8) throw new Error('Truncated UDP');
  const sport=be16(buf,off), dport=be16(buf,off+2), len=be16(buf,off+4), chks=be16(buf,off+6);
  const node = {
    _range:[off,off+8], layer:'udp',
    summary:`User Datagram Protocol, ${sport} → ${dport}, Len: ${len}`,
    fields:[
      ['Source Port', sport, [off,off+2]],
      ['Destination Port', dport, [off+2,off+4]],
      ['Length', len, [off+4,off+6]],
      ['Checksum', '0x'+chks.toString(16).padStart(4,'0'), [off+6,off+8]]
    ],
    sport, dport, len
  };
  const payloadOff = off+8; const payloadEnd = (end && len? (off+len): end);
  const pl = buf.slice(payloadOff, payloadEnd);
  let app=null;
  // Try DNS
  if(pl.length>=12 && (sport===53 || dport===53)){
    try{ app=parseDNS(pl, payloadOff); }catch(_){}
  }
  return {node, next: app?'app':null, nextNode: app, nextOff: payloadOff + (app?app._len:0)};
}

function parseDNS(p, baseOff){
  if(p.length<12) throw new Error('Truncated DNS');
  const id=be16(p,0), flags=be16(p,2), qd=be16(p,4), an=be16(p,6), ns=be16(p,8), ar=be16(p,10);
  let off=12, qname='(none)';
  if(qd>0){
    const parts=[];
    while(off<p.length){
      const len=p[off++];
      if(len===0) break;
      if(off+len>p.length) break;
      parts.push(new TextDecoder().decode(p.slice(off,off+len)));
      off+=len;
    }
    qname=parts.join('.');
    if(off+4<=p.length){ off+=4; } // QTYPE/QCLASS
  }
  const node = {
    _range:[baseOff, baseOff+off],
    layer:'dns',
    summary:`Domain Name System: ${qd} Q, ${an} Ans — ${qname}`,
    fields:[
      ['Transaction ID', '0x'+id.toString(16).padStart(4,'0'), [baseOff,baseOff+2]],
      ['Flags', '0x'+flags.toString(16).padStart(4,'0'), [baseOff+2,baseOff+4]],
      ['Questions', qd, [baseOff+4,baseOff+6]],
      ['Answer RRs', an, [baseOff+6,baseOff+8]],
      ['Authority RRs', ns, [baseOff+8,baseOff+10]],
      ['Additional RRs', ar, [baseOff+10,baseOff+12]],
      ['Query Name', qname, null],
    ],
    _len: off, qname
  };
  return node;
}

function parseICMPv4(buf, off, end){
  if(buf.length-off<4) throw new Error('Truncated ICMPv4');
  const type=buf[off], code=buf[off+1], chks=be16(buf,off+2);
  const node={
    _range:[off,off+4],
    layer:'icmpv4',
    summary:`Internet Control Message Protocol v4, Type ${type} Code ${code}`,
    fields:[
      ['Type', type, [off,off+1]],
      ['Code', code, [off+1,off+2]],
      ['Checksum', '0x'+chks.toString(16).padStart(4,'0'), [off+2,off+4]]
    ],
    type, code
  };
  return {node, next:null, nextOff: off+4};
}
function parseICMPv6(buf, off, end){
  if(buf.length-off<4) throw new Error('Truncated ICMPv6');
  const type=buf[off], code=buf[off+1], chks=be16(buf,off+2);
  const node={
    _range:[off,off+4],
    layer:'icmpv6',
    summary:`Internet Control Message Protocol v6, Type ${type} Code ${code}`,
    fields:[
      ['Type', type, [off,off+1]],
      ['Code', code, [off+1,off+2]],
      ['Checksum', '0x'+chks.toString(16).padStart(4,'0'), [off+2,off+4]]
    ],
    type, code
  };
  return {node, next:null, nextOff: off+4};
}

/* ============================== Dissector ============================== */
function dissect(buf){
  const layers=[]; let off=0, next='eth', payloadEnd=null;
  let flat = { 'frame.len': buf.length };
  // Ethernet always first here
  const eth = parseEthernet(buf,off); layers.push(eth.node); off=eth.nextOff; next=eth.next;
  flat['eth.src']=eth.node.src; flat['eth.dst']=eth.node.dst;
  if(next==='arp'){ const a=parseARP(buf,off); layers.push(a.node); return {layers, flat, buf}; }
  if(next==='ipv4'){
    const ip=parseIPv4(buf,off); layers.push(ip.node); off=ip.nextOff; payloadEnd=ip.payloadEnd; next=ip.next;
    flat['ip.src']=ip.node.src; flat['ip.dst']=ip.node.dst; flat['ip.proto']=ip.node.proto;
  } else if(next==='ipv6'){
    const ip6=parseIPv6(buf,off); layers.push(ip6.node); off=ip6.nextOff; payloadEnd=ip6.payloadEnd; next=ip6.next;
    flat['ipv6.src']=ip6.node.src; flat['ipv6.dst']=ip6.node.dst; flat['ipv6.nh']=ip6.node.nextHdr;
  } else {
    return {layers, flat, buf};
  }
  if(next==='tcp'){
    const tcp=parseTCP(buf,off,payloadEnd); layers.push(tcp.node); flat['tcp.srcport']=tcp.node.sport; flat['tcp.dstport']=tcp.node.dport;
    off=tcp.nextOff;
    if(tcp.nextNode){ layers.push(tcp.nextNode); if(tcp.nextNode.layer==='http'){ flat['http']=true; flat['http.start']=tcp.nextNode.startLine; } }
  }else if(next==='udp'){
    const udp=parseUDP(buf,off,payloadEnd); layers.push(udp.node); flat['udp.srcport']=udp.node.sport; flat['udp.dstport']=udp.node.dport;
    off=udp.nextOff;
    if(udp.nextNode){ layers.push(udp.nextNode); if(udp.nextNode.layer==='dns'){ flat['dns']=true; flat['dns.qname']=udp.nextNode.qname; } }
  }else if(next==='icmpv4'){
    const ic=parseICMPv4(buf,off,payloadEnd); layers.push(ic.node); flat['icmp']=true;
  }else if(next==='icmpv6'){
    const ic6=parseICMPv6(buf,off,payloadEnd); layers.push(ic6.node); flat['icmpv6']=true;
  }
  return {layers, flat, buf};
}

/* ============================== Random Generators ============================== */
function genEthernetHeader(ethType){
  const b=new Uint8Array(14);
  const dst=parseHexString(randMAC().replace(/:/g,''));
  const src=parseHexString(randMAC().replace(/:/g,''));
  b.set(dst,0); b.set(src,6); put16(b,12,ethType);
  return b;
}
function genIPv4Header(proto, payloadLen){
  const ihl=20; const total=ihl+payloadLen;
  const b=new Uint8Array(ihl);
  b[0]=(4<<4)|(ihl/4); b[1]=0x00; put16(b,2,total);
  put16(b,4,Math.floor(Math.random()*0xffff));
  put16(b,6,0x4000); b[8]=64; b[9]=proto;
  put16(b,10,0); // chks later
  const sIP=randIPv4().split('.').map(x=>+x);
  const dIP=randIPv4().split('.').map(x=>+x);
  b.set(sIP,12); b.set(dIP,16);
  put16(b,10, internetChecksum(b));
  return b;
}
function genIPv6Header(nextHdr, payloadLen){
  const b=new Uint8Array(40);
  b[0]=(6<<4); // tc/flow zero
  put16(b,4,payloadLen);
  b[6]=nextHdr; b[7]=64;
  // random addrs
  const s = parseHexString(randIPv6().replace(/:/g,'').padStart(32,'0'));
  const d = parseHexString(randIPv6().replace(/:/g,'').padStart(32,'0'));
  b.set(s,8); b.set(d,24);
  return b;
}
function genTCP(segLen, srcPort, dstPort, srcIP, dstIP, isIPv6){
  const doff=20;
  const b=new Uint8Array(doff+segLen);
  put16(b,0,srcPort); put16(b,2,dstPort);
  put32(b,4,Math.floor(Math.random()*0xffffffff));
  put32(b,8,0);
  b[12]=(doff/4)<<4; b[13]=0x02; // SYN
  put16(b,14,65535); put16(b,16,0); put16(b,18,0);
  // pseudo header checksum
  let pseudo;
  if(!isIPv6){
    pseudo=new Uint8Array(12 + b.length);
    pseudo.set(srcIP,0); pseudo.set(dstIP,4); pseudo[8]=0; pseudo[9]=6; put16(pseudo,10,b.length);
    pseudo.set(b,12);
  }else{
    pseudo=new Uint8Array(40 + b.length);
    pseudo.set(srcIP,0); pseudo.set(dstIP,16);
    put32(pseudo,32,b.length); pseudo[39]=6;
    pseudo.set(b,40);
  }
  put16(b,16,0);
  put16(b,16, internetChecksum(pseudo));
  return b;
}
function genUDP(plLen, srcPort, dstPort, srcIP, dstIP, isIPv6){
  const b=new Uint8Array(8+plLen);
  put16(b,0,srcPort); put16(b,2,dstPort); put16(b,4,b.length); put16(b,6,0);
  // checksum
  let pseudo;
  if(!isIPv6){
    pseudo=new Uint8Array(12 + b.length);
    pseudo.set(srcIP,0); pseudo.set(dstIP,4); pseudo[8]=0; pseudo[9]=17; put16(pseudo,10,b.length);
    pseudo.set(b,12);
  }else{
    pseudo=new Uint8Array(40 + b.length);
    pseudo.set(srcIP,0); pseudo.set(dstIP,16);
    put32(pseudo,32,b.length); pseudo[39]=17;
    pseudo.set(b,40);
  }
  put16(b,6, internetChecksum(pseudo) || 0xffff); // avoid zero
  return b;
}
function genICMPv4(payloadLen){
  const b=new Uint8Array(4+payloadLen);
  b[0]=8; b[1]=0; put16(b,2,0);
  put16(b,2, internetChecksum(b));
  return b;
}
function genICMPv6(payloadLen, srcIP6, dstIP6){
  const b=new Uint8Array(4+payloadLen);
  b[0]=128; b[1]=0; put16(b,2,0);
  // pseudo-header for v6
  const pseudo=new Uint8Array(40 + b.length);
  pseudo.set(srcIP6,0); pseudo.set(dstIP6,16);
  put32(pseudo,32,b.length); pseudo[39]=58;
  pseudo.set(b,40);
  put16(b,2, internetChecksum(pseudo) || 0xffff);
  return b;
}
function genDNSQuery(name){
  const q = [];
  const id = Math.floor(Math.random()*0xffff);
  q.push((id>>8)&0xff, id&0xff, 0x01,0x00, 0x00,0x01, 0x00,0x00, 0x00,0x00, 0x00,0x00); // standard query, 1 Q
  name.split('.').forEach(lbl=>{
    q.push(lbl.length & 0xff);
    for(const c of lbl) q.push(c.charCodeAt(0));
  });
  q.push(0x00); // end
  q.push(0x00,0x01, 0x00,0x01); // QTYPE=A, QCLASS=IN
  return new Uint8Array(q);
}
function genHTTPRequest(){
  const host = `www.example${Math.floor(Math.random()*100)}.org`;
  const path = `/path${Math.floor(Math.random()*100)}`;
  const raw = `GET ${path} HTTP/1.1\r\nHost: ${host}\r\nUser-Agent: LabClient/1.0\r\nAccept: */*\r\nConnection: close\r\n\r\n`;
  return textEnc(raw);
}

/* ============================== Filter Engine ============================== */
function matchFilter(pkt, expr){
  if(!expr) return true;
  // very small parser: supports "and/or", "==", "contains", bare proto keywords.
  // Normalize
  expr = expr.replace(/\s+/g,' ').trim();
  // Split by ' or ' top-level, then ' and '
  const orParts = splitTop(expr, ' or ');
  return orParts.some(part=>{
    const andParts = splitTop(part, ' and ');
    return andParts.every(cond=>matchCond(pkt, cond.trim()));
  });
}
function splitTop(s, sep){
  const out=[]; let i=0; while(true){
    const j = s.toLowerCase().indexOf(sep, i);
    if(j<0){ out.push(s.slice(i)); break; }
    out.push(s.slice(i,j)); i=j+sep.length;
  } return out;
}
function matchCond(pkt, c){
  if(!c) return true;
  // proto words
  if(/^tcp$/i.test(c)) return pkt.flat['tcp.srcport']!=null || pkt.flat['tcp.dstport']!=null;
  if(/^udp$/i.test(c)) return pkt.flat['udp.srcport']!=null || pkt.flat['udp.dstport']!=null;
  if(/^icmp$/i.test(c)) return !!pkt.flat['icmp'];
  if(/^icmpv6$/i.test(c)) return !!pkt.flat['icmpv6'];
  if(/^dns$/i.test(c)) return !!pkt.flat['dns'];
  if(/^http$/i.test(c)) return !!pkt.flat['http'];
  const mEq = c.match(/^([a-z0-9\.\_]+)\s*==\s*(.+)$/i);
  const mNe = c.match(/^([a-z0-9\.\_]+)\s*!=\s*(.+)$/i);
  const mContains = c.match(/^([a-z0-9\.\_]+)\s*contains\s*(.+)$/i);
  if(mEq){
    const k=mEq[1].toLowerCase(), v=stripQuotes(mEq[2]);
    if(k==='proto'){ return (pkt.proto||'').toLowerCase()===String(v).toLowerCase(); }
    return String(pkt.flat[k]??'').toLowerCase() === String(v).toLowerCase();
  }
  if(mNe){
    const k=mNe[1].toLowerCase(), v=stripQuotes(mNe[2]);
    return String(pkt.flat[k]??'').toLowerCase() !== String(v).toLowerCase();
  }
  if(mContains){
    const k=mContains[1].toLowerCase(), v=stripQuotes(mContains[2]).toLowerCase();
    return String(pkt.flat[k]??'').toLowerCase().includes(v);
  }
  // tcp.port == N sugar
  const mPort = c.match(/^(tcp|udp)\.port\s*==\s*(\d+)$/i);
  if(mPort){
    const proto=mPort[1].toLowerCase(), val=+mPort[2];
    if(proto==='tcp') return pkt.flat['tcp.srcport']==val || pkt.flat['tcp.dstport']==val;
    if(proto==='udp') return pkt.flat['udp.srcport']==val || pkt.flat['udp.dstport']==val;
  }
  // ip/ipv6 src/dst short
  if(/^ip\.src\s*==\s*/i.test(c)) return matchCond(pkt, c.replace(/^ip\./i,'ip.'));
  if(/^ip\.dst\s*==\s*/i.test(c)) return matchCond(pkt, c.replace(/^ip\./i,'ip.'));
  return false;
}
function stripQuotes(s){ s=s.trim(); return s.replace(/^["']|["']$/g,''); }

/* ============================== Rendering ============================== */
let PKTS=[]; // {layers, flat, buf, id}
function addPacketFromBytes(buf){
  const d = dissect(buf);
  const id = PKTS.length+1;
  // derive proto badge for summary
  let proto='other';
  if(d.flat['tcp.srcport']!=null) proto='tcp';
  else if(d.flat['udp.srcport']!=null) proto='udp';
  else if(d.flat['icmp']) proto='icmp';
  else if(d.flat['icmpv6']) proto='icmpv6';
  else if(d.flat['dns']) proto='dns';
  else if(d.flat['http']) proto='http';
  d.proto=proto;
  PKTS.push({...d, id});
  render();
}

function render(filterText=''){
  const cont=document.getElementById('packets'); cont.innerHTML='';
  const filtered = PKTS.filter(p=>matchFilter(p, filterText));
  document.getElementById('pktCount').textContent = filtered.length;
  filtered.forEach(p=>{
    const card=document.createElement('div'); card.className='packet';
    // title
    const title = p.layers[0]?.summary || `Frame ${p.id}`;
    card.innerHTML = `
      <div class="pkt-head">
        <div class="pkt-title">#${p.id} — ${title}</div>
        <div class="inline">
          <span class="pill">${p.proto.toUpperCase()}</span>
          <span class="pill">${p.buf.length} bytes</span>
        </div>
      </div>
      <div class="tree" id="tree-${p.id}"></div>
      <div class="hexwrap">
        <pre class="hex" id="hex-${p.id}"></pre>
      </div>
    `;
    cont.appendChild(card);
    // tree
    const tree = document.getElementById(`tree-${p.id}`);
    p.layers.forEach(layer=>{
      const det=document.createElement('details'); det.open=true;
      const sum=document.createElement('summary'); sum.textContent=layer.summary;
      det.appendChild(sum);
      layer.fields.forEach(([k,v,range])=>{
        const div=document.createElement('div'); div.className='node';
        div.innerHTML = `<span class="k">${k}:</span> <span class="v">${escapeHTML(String(v))}</span>`;
        if(range){
          div.style.cursor='pointer';
          div.title='Click to highlight in hex view';
          div.addEventListener('click', ()=> highlightRange(p.id, range[0], range[1]));
        }
        det.appendChild(div);
      });
      tree.appendChild(det);
    });
    // hex
    const pre=document.getElementById(`hex-${p.id}`);
    pre.textContent = hexPretty(p.buf) + '\n\nASCII: ' + Array.from(p.buf).map(b=>(b>=32&&b<127)?String.fromCharCode(b):'.').join('');
  });
}

function highlightRange(id, start, end){
  const pre = document.getElementById(`hex-${id}`);
  if(!pre) return;
  // rebuild highlighted hex with byte-based selection
  const buf = PKTS.find(x=>x.id===id).buf;
  let out='', ascii='';
  for(let i=0;i<buf.length;i++){
    if(i%16===0){ out += (i===0?'':'\n') + i.toString(16).padStart(4,'0')+'  '; ascii=''; }
    const byte = buf[i].toString(16).padStart(2,'0').toUpperCase();
    const sep = (i%2?' ':'');
    const highlighted = (i>=start && i<end);
    out += highlighted ? `[${byte}]` : ` ${byte}`;
    if(!highlighted && i%2===0) out = out.replace(/ $/, ''); // tidy
    ascii += (buf[i]>=32 && buf[i]<127)?String.fromCharCode(buf[i]):'.';
    if(i%16===15){ out += '  ' + ascii; ascii=''; }
  }
  if(buf.length%16!==0){
    const rem = 16 - (buf.length%16);
    out += ' '.repeat(rem*3) + ' ' + ascii;
  }
  pre.textContent = out + '\n\nASCII: ' + Array.from(buf).map((b,i)=> (i>=start && i<end)?'•':((b>=32&&b<127)?String.fromCharCode(b):'.')).join('');
}
function escapeHTML(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[m])); }

/* ============================== Wiring ============================== */
const statusEl = document.getElementById('status');
document.getElementById('btnDecode').addEventListener('click', ()=>{
  try{
    const hex=document.getElementById('hexInput').value.trim();
    const buf=parseHexString(hex);
    addPacketFromBytes(buf);
    status('Decoded 1 packet.', true);
  }catch(e){ status(e.message,false); }
});
document.getElementById('btnClear').addEventListener('click', ()=>{
  PKTS=[]; render(); status('Cleared.', true);
});
document.getElementById('btnFilter').addEventListener('click', ()=>{
  const f=document.getElementById('filter').value.trim();
  render(f);
  status(`Filter applied: ${f||'(none)'}`, true);
});
document.getElementById('btnReset').addEventListener('click', ()=>{
  document.getElementById('filter').value=''; render(''); status('Filter reset.', true);
});
document.getElementById('selNet').addEventListener('change', syncSelectors);
document.getElementById('selTrans').addEventListener('change', syncSelectors);
function syncSelectors(){
  const net = document.getElementById('selNet').value;
  const trans = document.getElementById('selTrans');
  // ICMPv4 only with IPv4; ICMPv6 only with IPv6
  [...trans.options].forEach(o=>{
    if(o.value==='icmpv4') o.disabled = (net!=='ipv4');
    if(o.value==='icmpv6') o.disabled = (net!=='ipv6');
  });
  if(net==='arp'){ trans.value=''; document.getElementById('selApp').value=''; }
}
document.getElementById('btnGen').addEventListener('click', ()=>{
  try{
    const net=document.getElementById('selNet').value;
    const trans=document.getElementById('selTrans').value;
    const app=document.getElementById('selApp').value;
    if(net==='arp'){ // simple ARP within Ethernet
      const eth = genEthernetHeader(0x0806);
      const arp = new Uint8Array(28);
      put16(arp,0,1); put16(arp,2,0x0800); arp[4]=6; arp[5]=4; put16(arp,6,1);
      const sha=parseHexString(randMAC().replace(/:/g,'')); const spa=randIPv4().split('.').map(x=>+x);
      arp.set(sha,8); arp.set(spa,14);
      // tmac/ip zero
      const frame = new Uint8Array(eth.length + arp.length);
      frame.set(eth,0); frame.set(arp,eth.length);
      addPacketFromBytes(frame);
      status('Generated Ethernet+ARP', true);
      return;
    }
    // else IPv4/IPv6 path
    const isV6 = net==='ipv6';
    let appBytes = new Uint8Array(0);
    let udpOrTcp=null; // 'tcp' or 'udp'
    if(app==='dns'){ appBytes = genDNSQuery('www.example.com'); udpOrTcp='udp'; }
    if(app==='http'){ appBytes = genHTTPRequest(); udpOrTcp='tcp'; }
    // choose transports if none
    let t = trans || (udpOrTcp||'tcp');
    let payload = new Uint8Array(0);
    let srcPort = randPort(), dstPort = (t==='tcp'?(app==='http'?80: (Math.random()<.5?80:443)) : (app==='dns'?53: 53));
    if(t==='udp' && appBytes.length===0){ // filler UDP payload
      payload = rand(12);
    } else if(t==='tcp' && appBytes.length===0){
      payload = rand(0); // SYN has no payload
    } else {
      payload = appBytes;
    }

    // Build link + network + transport
    let ethType = isV6?0x86dd:0x0800;
    const eth = genEthernetHeader(ethType);
    let netHdr, srcIP, dstIP, protoNum;
    if(!isV6){
      if(t==='tcp'){ protoNum=6; }
      else if(t==='udp'){ protoNum=17; }
      else if(t==='icmpv4'){ protoNum=1; }
      else if(t==='icmpv6'){ throw new Error('ICMPv6 requires IPv6'); }
      // we need src/dst for checksums
      srcIP = randIPv4().split('.').map(x=>+x);
      dstIP = randIPv4().split('.').map(x=>+x);
      // transport
      let transBytes;
      if(t==='tcp'){
        transBytes = genTCP(payload.length, srcPort, dstPort, srcIP, dstIP, false);
        transBytes.set(payload, 20);
      }else if(t==='udp'){
        transBytes = genUDP(payload.length, srcPort, dstPort, srcIP, dstIP, false);
        transBytes.set(payload, 8);
      }else { // icmpv4
        transBytes = genICMPv4(8); // small payload
      }
      netHdr = genIPv4Header(protoNum, transBytes.length);
      // insert our random IPs into header (genIPv4Header created its own, override + recompute checksum)
      netHdr.set(srcIP,12); netHdr.set(dstIP,16); put16(netHdr,10,0); put16(netHdr,10,internetChecksum(netHdr));
      const frame = new Uint8Array(eth.length + netHdr.length + transBytes.length);
      frame.set(eth,0); frame.set(netHdr,eth.length); frame.set(transBytes, eth.length+netHdr.length);
      addPacketFromBytes(frame);
      status(`Generated Ethernet+IPv4+${t.toUpperCase()}${app?('+'+app.toUpperCase()):''}`, true);
    } else {
      if(t==='icmpv4') throw new Error('ICMPv4 requires IPv4');
      if(t==='tcp'){ protoNum=6; } else if(t==='udp'){ protoNum=17; } else if(t==='icmpv6'){ protoNum=58; }
      const src6 = parseHexString(randIPv6().replace(/:/g,'').padStart(32,'0'));
      const dst6 = parseHexString(randIPv6().replace(/:/g,'').padStart(32,'0'));
      let transBytes;
      if(t==='tcp'){
        transBytes = genTCP(payload.length, srcPort, dstPort, src6, dst6, true);
        transBytes.set(payload, 20);
      }else if(t==='udp'){
        transBytes = genUDP(payload.length, srcPort, dstPort, src6, dst6, true);
        transBytes.set(payload, 8);
      }else{ // icmpv6
        transBytes = genICMPv6(8, src6, dst6);
      }
      const ip6 = genIPv6Header(protoNum, transBytes.length);
      ip6.set(src6,8); ip6.set(dst6,24);
      const frame = new Uint8Array(eth.length + ip6.length + transBytes.length);
      frame.set(eth,0); frame.set(ip6,eth.length); frame.set(transBytes, eth.length+ip6.length);
      addPacketFromBytes(frame);
      status(`Generated Ethernet+IPv6+${t.toUpperCase()}${app?('+'+app.toUpperCase()):''}`, true);
    }
  }catch(e){ status(e.message,false); }
});

function status(msg, ok){ statusEl.textContent = msg; statusEl.className = 'status ' + (ok?'ok':'err'); }
syncSelectors();
render('');
</script>
</body>
</html>
